name: Submit Spark Evals Workflow

on:
  push:
    branches:
      - 'evals/**'
  pull_request:
    branches:
      - 'evals/**'

permissions:
  contents: read
  statuses: write  # Required for updating commit status via GitHub API

jobs:
  spark-evals-submit-workflow:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.EVALS_GCP_SA_KEY }}

      - name: Get GKE Credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ vars.EVALS_GKE_CLUSTER_NAME }}
          location: ${{ vars.EVALS_GKE_CLUSTER_ZONE }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure Docker for GCR
        run: |
          gcloud auth configure-docker gcr.io

      - name: Build and Push Spark Server Image
        env:
          PROJECT_ID: ${{ vars.EVALS_GCP_PROJECT_ID }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building Spark server image with tag: $IMAGE_TAG"

          docker build \
            --platform linux/amd64 \
            -f ./server/Dockerfile \
            -t spark-server:$IMAGE_TAG \
            .

          docker tag spark-server:$IMAGE_TAG gcr.io/$PROJECT_ID/spark-server:$IMAGE_TAG
          docker push gcr.io/$PROJECT_ID/spark-server:$IMAGE_TAG

          echo "✅ Image pushed to gcr.io/$PROJECT_ID/spark-server:$IMAGE_TAG"

      - name: Submit Argo Workflow
        run: |
          # Create a Kubernetes secret with the GitHub token for this workflow
          kubectl create secret generic github-token-${{ github.run_id }} \
            -n argo \
            --from-literal=token=${{ secrets.GITHUB_TOKEN }}

          kubectl create -f - <<EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Workflow
          metadata:
            generateName: spark-batch-github-eval-
            namespace: argo
          spec:
            workflowTemplateRef:
              name: spark-batch-eval-from-file
            arguments:
              parameters:
              - name: evaluations-gcs-key
                value: "eval-inputs/test.jsonl"
              - name: agent-version
                value: "${{ github.sha }}"
              # GitHub context for status updates
              - name: github-repo
                value: "${{ github.repository }}"
              - name: github-sha
                value: "${{ github.sha }}"
              - name: github-ref
                value: "${{ github.ref }}"
              - name: github-run-id
                value: "${{ github.run_id }}"
              # Secret name containing GitHub token
              - name: github-token-secret
                value: "github-token-${{ github.run_id }}"
          EOF

          echo "Workflow submitted successfully"

          # Get the workflow name
          WORKFLOW_NAME=$(kubectl get workflows -n argo --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}')
          echo "Workflow name: $WORKFLOW_NAME"
          echo "View in Argo UI:"
          echo "kubectl -n argo port-forward service/argo-server 2746:2746"
          echo "https://localhost:2746/workflows/argo/$WORKFLOW_NAME"

      - name: Wait for Workflow Completion
        run: |
          WORKFLOW_NAME=$(kubectl get workflows -n argo --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}')
          echo "Waiting for workflow $WORKFLOW_NAME to complete..."

          # Wait for workflow to complete (max 60 minutes)
          TIMEOUT=3600
          ELAPSED=0
          INTERVAL=10

          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Get workflow status details
            PHASE=$(kubectl get workflow -n argo $WORKFLOW_NAME -o jsonpath='{.status.phase}')
            PROGRESS=$(kubectl get workflow -n argo $WORKFLOW_NAME -o jsonpath='{.status.progress}')
            MESSAGE=$(kubectl get workflow -n argo $WORKFLOW_NAME -o jsonpath='{.status.message}')

            # Count node statuses
            SUCCEEDED=$(kubectl get workflow -n argo $WORKFLOW_NAME -o json | jq '[.status.nodes // {} | .[] | select(.phase=="Succeeded")] | length')
            FAILED=$(kubectl get workflow -n argo $WORKFLOW_NAME -o json | jq '[.status.nodes // {} | .[] | select(.phase=="Failed")] | length')
            RUNNING=$(kubectl get workflow -n argo $WORKFLOW_NAME -o json | jq '[.status.nodes // {} | .[] | select(.phase=="Running")] | length')

            # Build status line
            STATUS_LINE="[$ELAPSED s] Phase: $PHASE"
            if [ -n "$PROGRESS" ]; then
              STATUS_LINE="$STATUS_LINE | Progress: $PROGRESS"
            fi
            STATUS_LINE="$STATUS_LINE | ✅ $SUCCEEDED | ❌ $FAILED | ⚙️  $RUNNING"
            if [ -n "$MESSAGE" ]; then
              STATUS_LINE="$STATUS_LINE | $MESSAGE"
            fi

            echo "$STATUS_LINE"

            if [ "$PHASE" = "Succeeded" ]; then
              echo "✅ Workflow completed successfully!"
              exit 0
            elif [ "$PHASE" = "Failed" ] || [ "$PHASE" = "Error" ]; then
              echo "❌ Workflow failed with phase: $PHASE"
              echo "View logs with: kubectl logs -n argo -l workflows.argoproj.io/workflow=$WORKFLOW_NAME"
              exit 1
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "⏱️ Workflow timed out after ${TIMEOUT}s"
          echo "Current phase: $(kubectl get workflow -n argo $WORKFLOW_NAME -o jsonpath='{.status.phase}')"
          exit 1

      - name: Cleanup GitHub Token Secret
        if: always()
        run: |
          # Clean up the temporary secret after workflow submission
          kubectl delete secret github-token-${{ github.run_id }} -n argo --ignore-not-found=true