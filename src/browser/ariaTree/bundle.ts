// AUTO-GENERATED by scripts/bundle-aria-tree.ts â€” do not edit
// Regenerate with: pnpm run bundle:aria
export const ARIA_TREE_SCRIPT =
  '"use strict";\nvar __sparkAriaTree = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === "object" || typeof from === "function") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n  // src/browser/ariaTree/ariaSnapshot.ts\n  var ariaSnapshot_exports = {};\n  __export(ariaSnapshot_exports, {\n    applySetOfMarks: () => applySetOfMarks,\n    generateAndRenderAriaTree: () => generateAndRenderAriaTree,\n    isInteractiveElement: () => isInteractiveElement,\n    removeSetOfMarks: () => removeSetOfMarks\n  });\n\n  // src/browser/ariaTree/stringUtils.ts\n  function normalizeWhiteSpace(text) {\n    if (!text) return "";\n    return text.replace(/[\\u200b\\u00ad]/g, "").trim().replace(/\\s+/g, " ");\n  }\n\n  // src/browser/ariaTree/domUtils.ts\n  function parentElementOrShadowHost(element) {\n    if (element.parentElement) return element.parentElement;\n    if (!element.parentNode) return;\n    if (element.parentNode.nodeType === 11 && element.parentNode.host)\n      return element.parentNode.host;\n  }\n  function enclosingShadowRootOrDocument(element) {\n    let node = element;\n    while (node.parentNode) node = node.parentNode;\n    if (node.nodeType === 11 || node.nodeType === 9)\n      return node;\n  }\n  function enclosingShadowHost(element) {\n    while (element.parentElement) element = element.parentElement;\n    return parentElementOrShadowHost(element);\n  }\n  function closestCrossShadow(element, css, scope) {\n    while (element) {\n      const closest = element.closest(css);\n      if (scope && closest !== scope && closest?.contains(scope)) return;\n      if (closest) return closest;\n      element = enclosingShadowHost(element);\n    }\n  }\n  function getElementComputedStyle(element, pseudo) {\n    return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n  }\n  function isElementStyleVisibilityVisible(element, style) {\n    style = style ?? getElementComputedStyle(element);\n    if (!style) return true;\n    if (Element.prototype.checkVisibility) {\n      if (!element.checkVisibility()) return false;\n    } else {\n      const detailsOrSummary = element.closest("details,summary");\n      if (detailsOrSummary !== element && detailsOrSummary?.nodeName === "DETAILS" && !detailsOrSummary.open)\n        return false;\n    }\n    if (style.visibility !== "visible") return false;\n    return true;\n  }\n  function box(element) {\n    const style = getElementComputedStyle(element);\n    if (!style) return { visible: true };\n    if (style.display === "contents") {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === 1 && isElementVisible(child))\n          return { visible: true, style };\n        if (child.nodeType === 3 && isVisibleTextNode(child))\n          return { visible: true, style };\n      }\n      return { visible: false, style };\n    }\n    if (!isElementStyleVisibilityVisible(element, style)) return { style, visible: false };\n    const rect = element.getBoundingClientRect();\n    return { rect, style, visible: rect.width > 0 && rect.height > 0 };\n  }\n  function isElementVisible(element) {\n    return box(element).visible;\n  }\n  function isVisibleTextNode(node) {\n    const range = node.ownerDocument.createRange();\n    range.selectNode(node);\n    const rect = range.getBoundingClientRect();\n    return rect.width > 0 && rect.height > 0;\n  }\n  function elementSafeTagName(element) {\n    if (element instanceof HTMLFormElement) return "FORM";\n    return element.tagName.toUpperCase();\n  }\n\n  // src/browser/ariaTree/cssTokenizer.ts\n  var between = function(num, first, last) {\n    return num >= first && num <= last;\n  };\n  function digit(code) {\n    return between(code, 48, 57);\n  }\n  function hexdigit(code) {\n    return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n  }\n  function uppercaseletter(code) {\n    return between(code, 65, 90);\n  }\n  function lowercaseletter(code) {\n    return between(code, 97, 122);\n  }\n  function letter(code) {\n    return uppercaseletter(code) || lowercaseletter(code);\n  }\n  function nonascii(code) {\n    return code >= 128;\n  }\n  function namestartchar(code) {\n    return letter(code) || nonascii(code) || code === 95;\n  }\n  function namechar(code) {\n    return namestartchar(code) || digit(code) || code === 45;\n  }\n  function nonprintable(code) {\n    return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n  }\n  function newline(code) {\n    return code === 10;\n  }\n  function whitespace(code) {\n    return newline(code) || code === 9 || code === 32;\n  }\n  var maximumallowedcodepoint = 1114111;\n  function preprocess(str) {\n    const codepoints = [];\n    for (let i = 0; i < str.length; i++) {\n      let code = str.charCodeAt(i);\n      if (code === 13 && str.charCodeAt(i + 1) === 10) {\n        code = 10;\n        i++;\n      }\n      if (code === 13 || code === 12) code = 10;\n      if (code === 0) code = 65533;\n      if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n        const lead = code - 55296;\n        const trail = str.charCodeAt(i + 1) - 56320;\n        code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n        i++;\n      }\n      codepoints.push(code);\n    }\n    return codepoints;\n  }\n  function stringFromCode(code) {\n    if (code <= 65535) return String.fromCharCode(code);\n    code -= Math.pow(2, 16);\n    const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n    const trail = code % Math.pow(2, 10) + 56320;\n    return String.fromCharCode(lead) + String.fromCharCode(trail);\n  }\n  function tokenize(str1) {\n    const str = preprocess(str1);\n    let i = -1;\n    const tokens = [];\n    let code;\n    let line = 0;\n    let column = 0;\n    let lastLineLength = 0;\n    const incrLineno = function() {\n      line += 1;\n      lastLineLength = column;\n      column = 0;\n    };\n    const codepoint = function(i2) {\n      if (i2 >= str.length) return -1;\n      return str[i2];\n    };\n    const next = function(num) {\n      if (num === void 0) num = 1;\n      if (num > 3) throw "Spec Error: no more than three codepoints of lookahead.";\n      return codepoint(i + num);\n    };\n    const consume = function(num) {\n      if (num === void 0) num = 1;\n      i += num;\n      code = codepoint(i);\n      if (newline(code)) incrLineno();\n      else column += num;\n      return true;\n    };\n    const reconsume = function() {\n      i -= 1;\n      if (newline(code)) {\n        line -= 1;\n        column = lastLineLength;\n      } else {\n        column -= 1;\n      }\n      return true;\n    };\n    const eof = function(codepoint2) {\n      if (codepoint2 === void 0) codepoint2 = code;\n      return codepoint2 === -1;\n    };\n    const donothing = function() {\n    };\n    const parseerror = function() {\n    };\n    const consumeAToken = function() {\n      consumeComments();\n      consume();\n      if (whitespace(code)) {\n        while (whitespace(next())) consume();\n        return new WhitespaceToken();\n      } else if (code === 34) {\n        return consumeAStringToken();\n      } else if (code === 35) {\n        if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n          const token = new HashToken("");\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = "id";\n          token.value = consumeAName();\n          return token;\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 39) {\n        return consumeAStringToken();\n      } else if (code === 40) {\n        return new OpenParenToken();\n      } else if (code === 41) {\n        return new CloseParenToken();\n      } else if (code === 43) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 44) {\n        return new CommaToken();\n      } else if (code === 45) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else if (startsWithAnIdentifier()) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 46) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 58) {\n        return new ColonToken();\n      } else if (code === 59) {\n        return new SemicolonToken();\n      } else if (code === 64) {\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          return new AtKeywordToken(consumeAName());\n        else return new DelimToken(code);\n      } else if (code === 91) {\n        return new OpenSquareToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else {\n          parseerror();\n          return new DelimToken(code);\n        }\n      } else if (code === 93) {\n        return new CloseSquareToken();\n      } else if (code === 123) {\n        return new OpenCurlyToken();\n      } else if (code === 125) {\n        return new CloseCurlyToken();\n      } else if (digit(code)) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (namestartchar(code)) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else if (eof()) {\n        return new EOFToken();\n      } else {\n        return new DelimToken(code);\n      }\n    };\n    const consumeComments = function() {\n      while (next(1) === 47 && next(2) === 42) {\n        consume(2);\n        while (true) {\n          consume();\n          if (code === 42 && next() === 47) {\n            consume();\n            break;\n          } else if (eof()) {\n            parseerror();\n            return;\n          }\n        }\n      }\n    };\n    const consumeANumericToken = function() {\n      const num = consumeANumber();\n      if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n        const token = new DimensionToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        token.type = num.type;\n        token.unit = consumeAName();\n        return token;\n      } else if (next() === 37) {\n        consume();\n        const token = new PercentageToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        return token;\n      } else {\n        const token = new NumberToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        token.type = num.type;\n        return token;\n      }\n    };\n    const consumeAnIdentlikeToken = function() {\n      const str2 = consumeAName();\n      if (str2.toLowerCase() === "url" && next() === 40) {\n        consume();\n        while (whitespace(next(1)) && whitespace(next(2))) consume();\n        if (next() === 34 || next() === 39) return new FunctionToken(str2);\n        else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n          return new FunctionToken(str2);\n        else return consumeAURLToken();\n      } else if (next() === 40) {\n        consume();\n        return new FunctionToken(str2);\n      } else {\n        return new IdentToken(str2);\n      }\n    };\n    const consumeAStringToken = function(endingCodePoint) {\n      if (endingCodePoint === void 0) endingCodePoint = code;\n      let string = "";\n      while (consume()) {\n        if (code === endingCodePoint || eof()) {\n          return new StringToken(string);\n        } else if (newline(code)) {\n          parseerror();\n          reconsume();\n          return new BadStringToken();\n        } else if (code === 92) {\n          if (eof(next())) donothing();\n          else if (newline(next())) consume();\n          else string += stringFromCode(consumeEscape());\n        } else {\n          string += stringFromCode(code);\n        }\n      }\n      throw new Error("Internal error");\n    };\n    const consumeAURLToken = function() {\n      const token = new URLToken("");\n      while (whitespace(next())) consume();\n      if (eof(next())) return token;\n      while (consume()) {\n        if (code === 41 || eof()) {\n          return token;\n        } else if (whitespace(code)) {\n          while (whitespace(next())) consume();\n          if (next() === 41 || eof(next())) {\n            consume();\n            return token;\n          } else {\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken();\n          }\n        } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        } else if (code === 92) {\n          if (startsWithAValidEscape()) {\n            token.value += stringFromCode(consumeEscape());\n          } else {\n            parseerror();\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken();\n          }\n        } else {\n          token.value += stringFromCode(code);\n        }\n      }\n      throw new Error("Internal error");\n    };\n    const consumeEscape = function() {\n      consume();\n      if (hexdigit(code)) {\n        const digits = [code];\n        for (let total = 0; total < 5; total++) {\n          if (hexdigit(next())) {\n            consume();\n            digits.push(code);\n          } else {\n            break;\n          }\n        }\n        if (whitespace(next())) consume();\n        let value = parseInt(\n          digits.map(function(x) {\n            return String.fromCharCode(x);\n          }).join(""),\n          16\n        );\n        if (value > maximumallowedcodepoint) value = 65533;\n        return value;\n      } else if (eof()) {\n        return 65533;\n      } else {\n        return code;\n      }\n    };\n    const areAValidEscape = function(c1, c2) {\n      if (c1 !== 92) return false;\n      if (newline(c2)) return false;\n      return true;\n    };\n    const startsWithAValidEscape = function() {\n      return areAValidEscape(code, next());\n    };\n    const wouldStartAnIdentifier = function(c1, c2, c3) {\n      if (c1 === 45) return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n      else if (namestartchar(c1)) return true;\n      else if (c1 === 92) return areAValidEscape(c1, c2);\n      else return false;\n    };\n    const startsWithAnIdentifier = function() {\n      return wouldStartAnIdentifier(code, next(1), next(2));\n    };\n    const wouldStartANumber = function(c1, c2, c3) {\n      if (c1 === 43 || c1 === 45) {\n        if (digit(c2)) return true;\n        if (c2 === 46 && digit(c3)) return true;\n        return false;\n      } else if (c1 === 46) {\n        if (digit(c2)) return true;\n        return false;\n      } else if (digit(c1)) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const startsWithANumber = function() {\n      return wouldStartANumber(code, next(1), next(2));\n    };\n    const consumeAName = function() {\n      let result = "";\n      while (consume()) {\n        if (namechar(code)) {\n          result += stringFromCode(code);\n        } else if (startsWithAValidEscape()) {\n          result += stringFromCode(consumeEscape());\n        } else {\n          reconsume();\n          return result;\n        }\n      }\n      throw new Error("Internal parse error");\n    };\n    const consumeANumber = function() {\n      let repr = "";\n      let type = "integer";\n      if (next() === 43 || next() === 45) {\n        consume();\n        repr += stringFromCode(code);\n      }\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n      if (next(1) === 46 && digit(next(2))) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = "number";\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      }\n      const c1 = next(1), c2 = next(2), c3 = next(3);\n      if ((c1 === 69 || c1 === 101) && digit(c2)) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = "number";\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = "number";\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      }\n      const value = +repr;\n      return { type, value, repr };\n    };\n    const consumeTheRemnantsOfABadURL = function() {\n      while (consume()) {\n        if (code === 41 || eof()) {\n          return;\n        } else if (startsWithAValidEscape()) {\n          consumeEscape();\n          donothing();\n        } else {\n          donothing();\n        }\n      }\n    };\n    let iterationCount = 0;\n    while (!eof(next())) {\n      tokens.push(consumeAToken());\n      iterationCount++;\n      if (iterationCount > str.length * 2) throw new Error("I\'m infinite-looping!");\n    }\n    return tokens;\n  }\n  var CSSParserToken = class {\n    tokenType = "";\n    value;\n    toJSON() {\n      return { token: this.tokenType };\n    }\n    toString() {\n      return this.tokenType;\n    }\n    toSource() {\n      return "" + this;\n    }\n  };\n  var BadStringToken = class extends CSSParserToken {\n    tokenType = "BADSTRING";\n  };\n  var BadURLToken = class extends CSSParserToken {\n    tokenType = "BADURL";\n  };\n  var WhitespaceToken = class extends CSSParserToken {\n    tokenType = "WHITESPACE";\n    toString() {\n      return "WS";\n    }\n    toSource() {\n      return " ";\n    }\n  };\n  var ColonToken = class extends CSSParserToken {\n    tokenType = ":";\n  };\n  var SemicolonToken = class extends CSSParserToken {\n    tokenType = ";";\n  };\n  var CommaToken = class extends CSSParserToken {\n    tokenType = ",";\n  };\n  var GroupingToken = class extends CSSParserToken {\n    value = "";\n    mirror = "";\n  };\n  var OpenCurlyToken = class extends GroupingToken {\n    tokenType = "{";\n    constructor() {\n      super();\n      this.value = "{";\n      this.mirror = "}";\n    }\n  };\n  var CloseCurlyToken = class extends GroupingToken {\n    tokenType = "}";\n    constructor() {\n      super();\n      this.value = "}";\n      this.mirror = "{";\n    }\n  };\n  var OpenSquareToken = class extends GroupingToken {\n    tokenType = "[";\n    constructor() {\n      super();\n      this.value = "[";\n      this.mirror = "]";\n    }\n  };\n  var CloseSquareToken = class extends GroupingToken {\n    tokenType = "]";\n    constructor() {\n      super();\n      this.value = "]";\n      this.mirror = "[";\n    }\n  };\n  var OpenParenToken = class extends GroupingToken {\n    tokenType = "(";\n    constructor() {\n      super();\n      this.value = "(";\n      this.mirror = ")";\n    }\n  };\n  var CloseParenToken = class extends GroupingToken {\n    tokenType = ")";\n    constructor() {\n      super();\n      this.value = ")";\n      this.mirror = "(";\n    }\n  };\n  var EOFToken = class extends CSSParserToken {\n    tokenType = "EOF";\n    toSource() {\n      return "";\n    }\n  };\n  var DelimToken = class extends CSSParserToken {\n    tokenType = "DELIM";\n    value = "";\n    constructor(code) {\n      super();\n      this.value = stringFromCode(code);\n    }\n    toString() {\n      return "DELIM(" + this.value + ")";\n    }\n    toSource() {\n      if (this.value === "\\\\") return "\\\\\\n";\n      else return this.value;\n    }\n  };\n  var StringValuedToken = class extends CSSParserToken {\n    value = "";\n  };\n  var IdentToken = class extends StringValuedToken {\n    constructor(val) {\n      super();\n      this.value = val;\n    }\n    tokenType = "IDENT";\n  };\n  var FunctionToken = class extends StringValuedToken {\n    tokenType = "FUNCTION";\n    mirror;\n    constructor(val) {\n      super();\n      this.value = val;\n      this.mirror = ")";\n    }\n  };\n  var AtKeywordToken = class extends StringValuedToken {\n    tokenType = "AT-KEYWORD";\n    constructor(val) {\n      super();\n      this.value = val;\n    }\n  };\n  var HashToken = class extends StringValuedToken {\n    tokenType = "HASH";\n    type;\n    constructor(val) {\n      super();\n      this.value = val;\n      this.type = "unrestricted";\n    }\n  };\n  var StringToken = class extends StringValuedToken {\n    tokenType = "STRING";\n    constructor(val) {\n      super();\n      this.value = val;\n    }\n  };\n  var URLToken = class extends StringValuedToken {\n    tokenType = "URL";\n    constructor(val) {\n      super();\n      this.value = val;\n    }\n  };\n  var NumberToken = class extends CSSParserToken {\n    tokenType = "NUMBER";\n    type;\n    repr;\n    constructor() {\n      super();\n      this.type = "integer";\n      this.repr = "";\n    }\n  };\n  var PercentageToken = class extends CSSParserToken {\n    tokenType = "PERCENTAGE";\n    repr;\n    constructor() {\n      super();\n      this.repr = "";\n    }\n  };\n  var DimensionToken = class extends CSSParserToken {\n    tokenType = "DIMENSION";\n    type;\n    repr;\n    unit;\n    constructor() {\n      super();\n      this.type = "integer";\n      this.repr = "";\n      this.unit = "";\n    }\n  };\n\n  // src/browser/ariaTree/roleUtils.ts\n  function hasExplicitAccessibleName(e) {\n    return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");\n  }\n  var kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";\n  var kGlobalAriaAttributes = [\n    ["aria-atomic", void 0],\n    ["aria-busy", void 0],\n    ["aria-controls", void 0],\n    ["aria-current", void 0],\n    ["aria-describedby", void 0],\n    ["aria-details", void 0],\n    ["aria-dropeffect", void 0],\n    ["aria-flowto", void 0],\n    ["aria-grabbed", void 0],\n    ["aria-hidden", void 0],\n    ["aria-keyshortcuts", void 0],\n    [\n      "aria-label",\n      [\n        "caption",\n        "code",\n        "deletion",\n        "emphasis",\n        "generic",\n        "insertion",\n        "paragraph",\n        "presentation",\n        "strong",\n        "subscript",\n        "superscript"\n      ]\n    ],\n    [\n      "aria-labelledby",\n      [\n        "caption",\n        "code",\n        "deletion",\n        "emphasis",\n        "generic",\n        "insertion",\n        "paragraph",\n        "presentation",\n        "strong",\n        "subscript",\n        "superscript"\n      ]\n    ],\n    ["aria-live", void 0],\n    ["aria-owns", void 0],\n    ["aria-relevant", void 0],\n    ["aria-roledescription", ["generic"]]\n  ];\n  function hasGlobalAriaAttribute(element, forRole) {\n    return kGlobalAriaAttributes.some(([attr, prohibited]) => {\n      return !prohibited?.includes(forRole || "") && element.hasAttribute(attr);\n    });\n  }\n  function hasTabIndex(element) {\n    return !Number.isNaN(Number(String(element.getAttribute("tabindex"))));\n  }\n  function isFocusable(element) {\n    return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));\n  }\n  function isNativelyFocusable(element) {\n    const tagName = elementSafeTagName(element);\n    if (["BUTTON", "DETAILS", "SELECT", "TEXTAREA"].includes(tagName)) return true;\n    if (tagName === "A" || tagName === "AREA") return element.hasAttribute("href");\n    if (tagName === "INPUT") return !element.hidden;\n    return false;\n  }\n  var kImplicitRoleByTagName = {\n    A: (e) => e.hasAttribute("href") ? "link" : null,\n    AREA: (e) => e.hasAttribute("href") ? "link" : null,\n    ARTICLE: () => "article",\n    ASIDE: () => "complementary",\n    BLOCKQUOTE: () => "blockquote",\n    BUTTON: () => "button",\n    CAPTION: () => "caption",\n    CODE: () => "code",\n    DATALIST: () => "listbox",\n    DD: () => "definition",\n    DEL: () => "deletion",\n    DETAILS: () => "group",\n    DFN: () => "term",\n    DIALOG: () => "dialog",\n    DT: () => "term",\n    EM: () => "emphasis",\n    FIELDSET: () => "group",\n    FIGURE: () => "figure",\n    FOOTER: (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",\n    FORM: (e) => hasExplicitAccessibleName(e) ? "form" : null,\n    H1: () => "heading",\n    H2: () => "heading",\n    H3: () => "heading",\n    H4: () => "heading",\n    H5: () => "heading",\n    H6: () => "heading",\n    HEADER: (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",\n    HR: () => "separator",\n    HTML: () => "document",\n    IMG: (e) => e.getAttribute("alt") === "" && !e.getAttribute("title") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? "presentation" : "img",\n    INPUT: (e) => {\n      const type = e.type.toLowerCase();\n      if (type === "search") return e.hasAttribute("list") ? "combobox" : "searchbox";\n      if (["email", "tel", "text", "url", ""].includes(type)) {\n        const list = getIdRefs(e, e.getAttribute("list"))[0];\n        return list && elementSafeTagName(list) === "DATALIST" ? "combobox" : "textbox";\n      }\n      if (type === "hidden") return null;\n      if (type === "file") return "button";\n      return inputTypeToRole[type] || "textbox";\n    },\n    INS: () => "insertion",\n    LI: () => "listitem",\n    MAIN: () => "main",\n    MARK: () => "mark",\n    MATH: () => "math",\n    MENU: () => "list",\n    METER: () => "meter",\n    NAV: () => "navigation",\n    OL: () => "list",\n    OPTGROUP: () => "group",\n    OPTION: () => "option",\n    OUTPUT: () => "status",\n    P: () => "paragraph",\n    PROGRESS: () => "progressbar",\n    SECTION: (e) => hasExplicitAccessibleName(e) ? "region" : null,\n    SELECT: (e) => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",\n    STRONG: () => "strong",\n    SUB: () => "subscript",\n    SUP: () => "superscript",\n    SVG: () => "img",\n    TABLE: () => "table",\n    TBODY: () => "rowgroup",\n    TD: (e) => {\n      const table = closestCrossShadow(e, "table");\n      const role = table ? getExplicitAriaRole(table) : "";\n      return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n    },\n    TEXTAREA: () => "textbox",\n    TFOOT: () => "rowgroup",\n    TH: (e) => {\n      if (e.getAttribute("scope") === "col") return "columnheader";\n      if (e.getAttribute("scope") === "row") return "rowheader";\n      const table = closestCrossShadow(e, "table");\n      const role = table ? getExplicitAriaRole(table) : "";\n      return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n    },\n    THEAD: () => "rowgroup",\n    TIME: () => "time",\n    TR: () => "row",\n    UL: () => "list"\n  };\n  var kPresentationInheritanceParents = {\n    DD: ["DL", "DIV"],\n    DIV: ["DL"],\n    DT: ["DL", "DIV"],\n    LI: ["OL", "UL"],\n    TBODY: ["TABLE"],\n    TD: ["TR"],\n    TFOOT: ["TABLE"],\n    TH: ["TR"],\n    THEAD: ["TABLE"],\n    TR: ["THEAD", "TBODY", "TFOOT", "TABLE"]\n  };\n  function getImplicitAriaRole(element) {\n    const implicitRole = kImplicitRoleByTagName[elementSafeTagName(element)]?.(element) || "";\n    if (!implicitRole) return null;\n    let ancestor = element;\n    while (ancestor) {\n      const parent = parentElementOrShadowHost(ancestor);\n      const parents = kPresentationInheritanceParents[elementSafeTagName(ancestor)];\n      if (!parents || !parent || !parents.includes(elementSafeTagName(parent))) break;\n      const parentExplicitRole = getExplicitAriaRole(parent);\n      if ((parentExplicitRole === "none" || parentExplicitRole === "presentation") && !hasPresentationConflictResolution(parent, parentExplicitRole))\n        return parentExplicitRole;\n      ancestor = parent;\n    }\n    return implicitRole;\n  }\n  var validRoles = [\n    "alert",\n    "alertdialog",\n    "application",\n    "article",\n    "banner",\n    "blockquote",\n    "button",\n    "caption",\n    "cell",\n    "checkbox",\n    "code",\n    "columnheader",\n    "combobox",\n    "complementary",\n    "contentinfo",\n    "definition",\n    "deletion",\n    "dialog",\n    "directory",\n    "document",\n    "emphasis",\n    "feed",\n    "figure",\n    "form",\n    "generic",\n    "grid",\n    "gridcell",\n    "group",\n    "heading",\n    "img",\n    "insertion",\n    "link",\n    "list",\n    "listbox",\n    "listitem",\n    "log",\n    "main",\n    "mark",\n    "marquee",\n    "math",\n    "meter",\n    "menu",\n    "menubar",\n    "menuitem",\n    "menuitemcheckbox",\n    "menuitemradio",\n    "navigation",\n    "none",\n    "note",\n    "option",\n    "paragraph",\n    "presentation",\n    "progressbar",\n    "radio",\n    "radiogroup",\n    "region",\n    "row",\n    "rowgroup",\n    "rowheader",\n    "scrollbar",\n    "search",\n    "searchbox",\n    "separator",\n    "slider",\n    "spinbutton",\n    "status",\n    "strong",\n    "subscript",\n    "superscript",\n    "switch",\n    "tab",\n    "table",\n    "tablist",\n    "tabpanel",\n    "term",\n    "textbox",\n    "time",\n    "timer",\n    "toolbar",\n    "tooltip",\n    "tree",\n    "treegrid",\n    "treeitem"\n  ];\n  function getExplicitAriaRole(element) {\n    const roles = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());\n    return roles.find((role) => validRoles.includes(role)) || null;\n  }\n  function hasPresentationConflictResolution(element, role) {\n    return hasGlobalAriaAttribute(element, role) || isFocusable(element);\n  }\n  function getAriaRole(element) {\n    const explicitRole = getExplicitAriaRole(element);\n    if (!explicitRole) return getImplicitAriaRole(element);\n    if (explicitRole === "none" || explicitRole === "presentation") {\n      const implicitRole = getImplicitAriaRole(element);\n      if (hasPresentationConflictResolution(element, implicitRole)) return implicitRole;\n    }\n    return explicitRole;\n  }\n  function getAriaBoolean(attr) {\n    return attr === null ? void 0 : attr.toLowerCase() === "true";\n  }\n  function isElementIgnoredForAria(element) {\n    return ["STYLE", "SCRIPT", "NOSCRIPT", "TEMPLATE"].includes(elementSafeTagName(element));\n  }\n  function isElementHiddenForAria(element) {\n    if (isElementIgnoredForAria(element)) return true;\n    const style = getElementComputedStyle(element);\n    const isSlot = element.nodeName === "SLOT";\n    if (style?.display === "contents" && !isSlot) {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === 1 && !isElementHiddenForAria(child))\n          return false;\n        if (child.nodeType === 3 && isVisibleTextNode(child))\n          return false;\n      }\n      return true;\n    }\n    const isOptionInsideSelect = element.nodeName === "OPTION" && !!element.closest("select");\n    if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n      return true;\n    return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\n  }\n  function belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\n    let hidden = cacheIsHidden?.get(element);\n    if (hidden === void 0) {\n      hidden = false;\n      if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n        hidden = true;\n      if (!hidden) {\n        const style = getElementComputedStyle(element);\n        hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true;\n      }\n      if (!hidden) {\n        const parent = parentElementOrShadowHost(element);\n        if (parent) hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\n      }\n      cacheIsHidden?.set(element, hidden);\n    }\n    return hidden;\n  }\n  function getIdRefs(element, ref) {\n    if (!ref) return [];\n    const root = enclosingShadowRootOrDocument(element);\n    if (!root) return [];\n    try {\n      const ids = ref.split(" ").filter((id) => !!id);\n      const result = [];\n      for (const id of ids) {\n        const firstElement = root.querySelector("#" + CSS.escape(id));\n        if (firstElement && !result.includes(firstElement)) result.push(firstElement);\n      }\n      return result;\n    } catch {\n      return [];\n    }\n  }\n  function trimFlatString(s) {\n    return s.trim();\n  }\n  function asFlatString(s) {\n    return s.split("\\xA0").map(\n      (chunk) => chunk.replace(/\\r\\n/g, "\\n").replace(/[\\u200b\\u00ad]/g, "").replace(/\\s\\s*/g, " ")\n    ).join("\\xA0").trim();\n  }\n  function queryInAriaOwned(element, selector) {\n    const result = [...element.querySelectorAll(selector)];\n    for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) {\n      if (owned.matches(selector)) result.push(owned);\n      result.push(...owned.querySelectorAll(selector));\n    }\n    return result;\n  }\n  function getCSSContent(element, pseudo) {\n    const cache = pseudo === "::before" ? cachePseudoContentBefore : pseudo === "::after" ? cachePseudoContentAfter : cachePseudoContent;\n    if (cache?.has(element)) return cache?.get(element);\n    const style = getElementComputedStyle(element, pseudo);\n    let content;\n    if (style && style.display !== "none" && style.visibility !== "hidden") {\n      content = parseCSSContentPropertyAsString(element, style.content, !!pseudo);\n    }\n    if (pseudo && content !== void 0) {\n      const display = style?.display || "inline";\n      if (display !== "inline") content = " " + content + " ";\n    }\n    if (cache) cache.set(element, content);\n    return content;\n  }\n  function parseCSSContentPropertyAsString(element, content, isPseudo) {\n    if (!content || content === "none" || content === "normal") {\n      return;\n    }\n    try {\n      let tokens = tokenize(content).filter((token) => !(token instanceof WhitespaceToken));\n      const delimIndex = tokens.findIndex(\n        (token) => token instanceof DelimToken && token.value === "/"\n      );\n      if (delimIndex !== -1) {\n        tokens = tokens.slice(delimIndex + 1);\n      } else if (!isPseudo) {\n        return;\n      }\n      const accumulated = [];\n      let index = 0;\n      while (index < tokens.length) {\n        if (tokens[index] instanceof StringToken) {\n          accumulated.push(tokens[index].value);\n          index++;\n        } else if (index + 2 < tokens.length && tokens[index] instanceof FunctionToken && tokens[index].value === "attr" && tokens[index + 1] instanceof IdentToken && tokens[index + 2] instanceof CloseParenToken) {\n          const attrName = tokens[index + 1].value;\n          accumulated.push(element.getAttribute(attrName) || "");\n          index += 3;\n        } else {\n          return;\n        }\n      }\n      return accumulated.join("");\n    } catch {\n    }\n  }\n  function getAriaLabelledByElements(element) {\n    const ref = element.getAttribute("aria-labelledby");\n    if (ref === null) return null;\n    const refs = getIdRefs(element, ref);\n    return refs.length ? refs : null;\n  }\n  function allowsNameFromContent(role, targetDescendant) {\n    const alwaysAllowsNameFromContent = [\n      "button",\n      "cell",\n      "checkbox",\n      "columnheader",\n      "gridcell",\n      "heading",\n      "link",\n      "menuitem",\n      "menuitemcheckbox",\n      "menuitemradio",\n      "option",\n      "radio",\n      "row",\n      "rowheader",\n      "switch",\n      "tab",\n      "tooltip",\n      "treeitem"\n    ].includes(role);\n    const descendantAllowsNameFromContent = targetDescendant && [\n      "",\n      "caption",\n      "code",\n      "contentinfo",\n      "definition",\n      "deletion",\n      "emphasis",\n      "insertion",\n      "list",\n      "listitem",\n      "mark",\n      "none",\n      "paragraph",\n      "presentation",\n      "region",\n      "row",\n      "rowgroup",\n      "section",\n      "strong",\n      "subscript",\n      "superscript",\n      "table",\n      "term",\n      "time"\n    ].includes(role);\n    return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n  }\n  function getElementAccessibleName(element, includeHidden) {\n    const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n    let accessibleName = cache?.get(element);\n    if (accessibleName === void 0) {\n      accessibleName = "";\n      const elementProhibitsNaming = [\n        "caption",\n        "code",\n        "definition",\n        "deletion",\n        "emphasis",\n        "generic",\n        "insertion",\n        "mark",\n        "paragraph",\n        "presentation",\n        "strong",\n        "subscript",\n        "suggestion",\n        "superscript",\n        "term",\n        "time"\n      ].includes(getAriaRole(element) || "");\n      if (!elementProhibitsNaming) {\n        accessibleName = asFlatString(\n          getTextAlternativeInternal(element, {\n            includeHidden,\n            visitedElements: /* @__PURE__ */ new Set(),\n            embeddedInTargetElement: "self"\n          })\n        );\n      }\n      cache?.set(element, accessibleName);\n    }\n    return accessibleName;\n  }\n  function getTextAlternativeInternal(element, options) {\n    if (options.visitedElements.has(element)) return "";\n    const childOptions = {\n      ...options,\n      embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement\n    };\n    if (!options.includeHidden) {\n      const isEmbeddedInHiddenReferenceTraversal = !!options.embeddedInLabelledBy?.hidden || !!options.embeddedInDescribedBy?.hidden || !!options.embeddedInNativeTextAlternative?.hidden || !!options.embeddedInLabel?.hidden;\n      if (isElementIgnoredForAria(element) || !isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element)) {\n        options.visitedElements.add(element);\n        return "";\n      }\n    }\n    const labelledBy = getAriaLabelledByElements(element);\n    if (!options.embeddedInLabelledBy) {\n      const accessibleName = (labelledBy || []).map(\n        (ref) => getTextAlternativeInternal(ref, {\n          ...options,\n          embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) },\n          embeddedInDescribedBy: void 0,\n          embeddedInTargetElement: void 0,\n          embeddedInLabel: void 0,\n          embeddedInNativeTextAlternative: void 0\n        })\n      ).join(" ");\n      if (accessibleName) return accessibleName;\n    }\n    const role = getAriaRole(element) || "";\n    const tagName = elementSafeTagName(element);\n    if (!!options.embeddedInLabel || !!options.embeddedInLabelledBy || options.embeddedInTargetElement === "descendant") {\n      const isOwnLabel = [\n        ...element.labels || []\n      ].includes(element);\n      const isOwnLabelledBy = (labelledBy || []).includes(element);\n      if (!isOwnLabel && !isOwnLabelledBy) {\n        if (role === "textbox") {\n          options.visitedElements.add(element);\n          if (tagName === "INPUT" || tagName === "TEXTAREA")\n            return element.value;\n          return element.textContent || "";\n        }\n        if (["combobox", "listbox"].includes(role)) {\n          options.visitedElements.add(element);\n          let selectedOptions;\n          if (tagName === "SELECT") {\n            selectedOptions = [...element.selectedOptions];\n            if (!selectedOptions.length && element.options.length)\n              selectedOptions.push(element.options[0]);\n          } else {\n            const listbox = role === "combobox" ? queryInAriaOwned(element, "*").find((e) => getAriaRole(e) === "listbox") : element;\n            selectedOptions = listbox ? queryInAriaOwned(listbox, \'[aria-selected="true"]\').filter(\n              (e) => getAriaRole(e) === "option"\n            ) : [];\n          }\n          if (!selectedOptions.length && tagName === "INPUT") {\n            return element.value;\n          }\n          return selectedOptions.map((option) => getTextAlternativeInternal(option, childOptions)).join(" ");\n        }\n        if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {\n          options.visitedElements.add(element);\n          if (element.hasAttribute("aria-valuetext"))\n            return element.getAttribute("aria-valuetext") || "";\n          if (element.hasAttribute("aria-valuenow"))\n            return element.getAttribute("aria-valuenow") || "";\n          return element.getAttribute("value") || "";\n        }\n        if (["menu"].includes(role)) {\n          options.visitedElements.add(element);\n          return "";\n        }\n      }\n    }\n    const ariaLabel = element.getAttribute("aria-label") || "";\n    if (trimFlatString(ariaLabel)) {\n      options.visitedElements.add(element);\n      return ariaLabel;\n    }\n    if (!["presentation", "none"].includes(role)) {\n      if (tagName === "INPUT" && ["button", "submit", "reset"].includes(element.type)) {\n        options.visitedElements.add(element);\n        const value = element.value || "";\n        if (trimFlatString(value)) return value;\n        if (element.type === "submit") return "Submit";\n        if (element.type === "reset") return "Reset";\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (tagName === "INPUT" && element.type === "file") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length && !options.embeddedInLabelledBy)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        return "Choose File";\n      }\n      if (tagName === "INPUT" && element.type === "image") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length && !options.embeddedInLabelledBy)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        const alt = element.getAttribute("alt") || "";\n        if (trimFlatString(alt)) return alt;\n        const title = element.getAttribute("title") || "";\n        if (trimFlatString(title)) return title;\n        return "Submit";\n      }\n      if (!labelledBy && tagName === "BUTTON") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length) return getAccessibleNameFromAssociatedLabels(labels, options);\n      }\n      if (!labelledBy && tagName === "OUTPUT") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length) return getAccessibleNameFromAssociatedLabels(labels, options);\n        return element.getAttribute("title") || "";\n      }\n      if (!labelledBy && (tagName === "TEXTAREA" || tagName === "SELECT" || tagName === "INPUT")) {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length) return getAccessibleNameFromAssociatedLabels(labels, options);\n        const usePlaceholder = tagName === "INPUT" && ["text", "password", "search", "tel", "email", "url"].includes(\n          element.type\n        ) || tagName === "TEXTAREA";\n        const placeholder = element.getAttribute("placeholder") || "";\n        const title = element.getAttribute("title") || "";\n        if (!usePlaceholder || title) return title;\n        return placeholder;\n      }\n      if (!labelledBy && tagName === "FIELDSET") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === "LEGEND") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: {\n                element: child,\n                hidden: isElementHiddenForAria(child)\n              }\n            });\n          }\n        }\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (!labelledBy && tagName === "FIGURE") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === "FIGCAPTION") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: {\n                element: child,\n                hidden: isElementHiddenForAria(child)\n              }\n            });\n          }\n        }\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (tagName === "IMG") {\n        options.visitedElements.add(element);\n        const alt = element.getAttribute("alt") || "";\n        if (trimFlatString(alt)) return alt;\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (tagName === "TABLE") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === "CAPTION") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: {\n                element: child,\n                hidden: isElementHiddenForAria(child)\n              }\n            });\n          }\n        }\n        const summary = element.getAttribute("summary") || "";\n        if (summary) return summary;\n      }\n      if (tagName === "AREA") {\n        options.visitedElements.add(element);\n        const alt = element.getAttribute("alt") || "";\n        if (trimFlatString(alt)) return alt;\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (tagName === "SVG" || element.ownerSVGElement) {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === "TITLE" && child.ownerSVGElement) {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInLabelledBy: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n      }\n      if (element.ownerSVGElement && tagName === "A") {\n        const title = element.getAttribute("xlink:title") || "";\n        if (trimFlatString(title)) {\n          options.visitedElements.add(element);\n          return title;\n        }\n      }\n    }\n    const shouldNameFromContentForSummary = tagName === "SUMMARY" && !["presentation", "none"].includes(role);\n    if (allowsNameFromContent(role, options.embeddedInTargetElement === "descendant") || shouldNameFromContentForSummary || !!options.embeddedInLabelledBy || !!options.embeddedInDescribedBy || !!options.embeddedInLabel || !!options.embeddedInNativeTextAlternative) {\n      options.visitedElements.add(element);\n      const accessibleName = innerAccumulatedElementText(element, childOptions);\n      const maybeTrimmedAccessibleName = options.embeddedInTargetElement === "self" ? trimFlatString(accessibleName) : accessibleName;\n      if (maybeTrimmedAccessibleName) return accessibleName;\n    }\n    if (!["presentation", "none"].includes(role) || tagName === "IFRAME") {\n      options.visitedElements.add(element);\n      const title = element.getAttribute("title") || "";\n      if (trimFlatString(title)) return title;\n    }\n    options.visitedElements.add(element);\n    return "";\n  }\n  function innerAccumulatedElementText(element, options) {\n    const tokens = [];\n    const visit = (node, skipSlotted) => {\n      if (skipSlotted && node.assignedSlot) return;\n      if (node.nodeType === 1) {\n        const display = getElementComputedStyle(node)?.display || "inline";\n        let token = getTextAlternativeInternal(node, options);\n        if (display !== "inline" || node.nodeName === "BR") token = " " + token + " ";\n        tokens.push(token);\n      } else if (node.nodeType === 3) {\n        tokens.push(node.textContent || "");\n      }\n    };\n    tokens.push(getCSSContent(element, "::before") || "");\n    const content = getCSSContent(element);\n    if (content !== void 0) {\n      tokens.push(content);\n    } else {\n      const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n      if (assignedNodes.length) {\n        for (const child of assignedNodes) visit(child, false);\n      } else {\n        for (let child = element.firstChild; child; child = child.nextSibling) visit(child, true);\n        if (element.shadowRoot) {\n          for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n            visit(child, true);\n        }\n        for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) visit(owned, true);\n      }\n    }\n    tokens.push(getCSSContent(element, "::after") || "");\n    return tokens.join("");\n  }\n  var kAriaSelectedRoles = [\n    "gridcell",\n    "option",\n    "row",\n    "tab",\n    "rowheader",\n    "columnheader",\n    "treeitem"\n  ];\n  function getAriaSelected(element) {\n    if (elementSafeTagName(element) === "OPTION") return element.selected;\n    if (kAriaSelectedRoles.includes(getAriaRole(element) || ""))\n      return getAriaBoolean(element.getAttribute("aria-selected")) === true;\n    return false;\n  }\n  var kAriaCheckedRoles = [\n    "checkbox",\n    "menuitemcheckbox",\n    "option",\n    "radio",\n    "switch",\n    "menuitemradio",\n    "treeitem"\n  ];\n  function getAriaChecked(element) {\n    const result = getChecked(element, true);\n    return result === "error" ? false : result;\n  }\n  function getChecked(element, allowMixed) {\n    const tagName = elementSafeTagName(element);\n    if (allowMixed && tagName === "INPUT" && element.indeterminate)\n      return "mixed";\n    if (tagName === "INPUT" && ["checkbox", "radio"].includes(element.type))\n      return element.checked;\n    if (kAriaCheckedRoles.includes(getAriaRole(element) || "")) {\n      const checked = element.getAttribute("aria-checked");\n      if (checked === "true") return true;\n      if (allowMixed && checked === "mixed") return "mixed";\n      return false;\n    }\n    return "error";\n  }\n  var kAriaPressedRoles = ["button"];\n  function getAriaPressed(element) {\n    if (kAriaPressedRoles.includes(getAriaRole(element) || "")) {\n      const pressed = element.getAttribute("aria-pressed");\n      if (pressed === "true") return true;\n      if (pressed === "mixed") return "mixed";\n    }\n    return false;\n  }\n  var kAriaExpandedRoles = [\n    "application",\n    "button",\n    "checkbox",\n    "combobox",\n    "gridcell",\n    "link",\n    "listbox",\n    "menuitem",\n    "row",\n    "rowheader",\n    "tab",\n    "treeitem",\n    "columnheader",\n    "menuitemcheckbox",\n    "menuitemradio",\n    "rowheader",\n    "switch"\n  ];\n  function getAriaExpanded(element) {\n    if (elementSafeTagName(element) === "DETAILS") return element.open;\n    if (kAriaExpandedRoles.includes(getAriaRole(element) || "")) {\n      const expanded = element.getAttribute("aria-expanded");\n      if (expanded === null) return void 0;\n      if (expanded === "true") return true;\n      return false;\n    }\n    return void 0;\n  }\n  var kAriaLevelRoles = ["heading", "listitem", "row", "treeitem"];\n  function getAriaLevel(element) {\n    const native = { H1: 1, H2: 2, H3: 3, H4: 4, H5: 5, H6: 6 }[elementSafeTagName(element)];\n    if (native) return native;\n    if (kAriaLevelRoles.includes(getAriaRole(element) || "")) {\n      const attr = element.getAttribute("aria-level");\n      const value = attr === null ? Number.NaN : Number(attr);\n      if (Number.isInteger(value) && value >= 1) return value;\n    }\n    return 0;\n  }\n  var kAriaDisabledRoles = [\n    "application",\n    "button",\n    "composite",\n    "gridcell",\n    "group",\n    "input",\n    "link",\n    "menuitem",\n    "scrollbar",\n    "separator",\n    "tab",\n    "checkbox",\n    "columnheader",\n    "combobox",\n    "grid",\n    "listbox",\n    "menu",\n    "menubar",\n    "menuitemcheckbox",\n    "menuitemradio",\n    "option",\n    "radio",\n    "radiogroup",\n    "row",\n    "rowheader",\n    "searchbox",\n    "select",\n    "slider",\n    "spinbutton",\n    "switch",\n    "tablist",\n    "textbox",\n    "toolbar",\n    "tree",\n    "treegrid",\n    "treeitem"\n  ];\n  function getAriaDisabled(element) {\n    return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);\n  }\n  function isNativelyDisabled(element) {\n    const isNativeFormControl = [\n      "BUTTON",\n      "INPUT",\n      "SELECT",\n      "TEXTAREA",\n      "OPTION",\n      "OPTGROUP"\n    ].includes(element.tagName);\n    return isNativeFormControl && (element.hasAttribute("disabled") || belongsToDisabledFieldSet(element));\n  }\n  function belongsToDisabledFieldSet(element) {\n    const fieldSetElement = element?.closest("FIELDSET[DISABLED]");\n    if (!fieldSetElement) return false;\n    const legendElement = fieldSetElement.querySelector(":scope > LEGEND");\n    return !legendElement || !legendElement.contains(element);\n  }\n  function hasExplicitAriaDisabled(element, isAncestor = false) {\n    if (!element) return false;\n    if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || "")) {\n      const attribute = (element.getAttribute("aria-disabled") || "").toLowerCase();\n      if (attribute === "true") return true;\n      if (attribute === "false") return false;\n      return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);\n    }\n    return false;\n  }\n  function getAccessibleNameFromAssociatedLabels(labels, options) {\n    return [...labels].map(\n      (label) => getTextAlternativeInternal(label, {\n        ...options,\n        embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) },\n        embeddedInNativeTextAlternative: void 0,\n        embeddedInLabelledBy: void 0,\n        embeddedInDescribedBy: void 0,\n        embeddedInTargetElement: void 0\n      })\n    ).filter((accessibleName) => !!accessibleName).join(" ");\n  }\n  function receivesPointerEvents(element) {\n    const cache = cachePointerEvents;\n    let e = element;\n    let result;\n    const parents = [];\n    for (; e; e = parentElementOrShadowHost(e)) {\n      const cached = cache.get(e);\n      if (cached !== void 0) {\n        result = cached;\n        break;\n      }\n      parents.push(e);\n      const style = getElementComputedStyle(e);\n      if (!style) {\n        result = true;\n        break;\n      }\n      const value = style.pointerEvents;\n      if (value) {\n        result = value !== "none";\n        break;\n      }\n    }\n    if (result === void 0) result = true;\n    for (const parent of parents) cache.set(parent, result);\n    return result;\n  }\n  var cacheAccessibleName;\n  var cacheAccessibleNameHidden;\n  var cacheIsHidden;\n  var cachePseudoContent;\n  var cachePseudoContentBefore;\n  var cachePseudoContentAfter;\n  var cachePointerEvents;\n  var cachesCounter = 0;\n  function beginAriaCaches() {\n    ++cachesCounter;\n    cacheAccessibleName ??= /* @__PURE__ */ new Map();\n    cacheAccessibleNameHidden ??= /* @__PURE__ */ new Map();\n    cacheIsHidden ??= /* @__PURE__ */ new Map();\n    cachePseudoContent ??= /* @__PURE__ */ new Map();\n    cachePseudoContentBefore ??= /* @__PURE__ */ new Map();\n    cachePseudoContentAfter ??= /* @__PURE__ */ new Map();\n    cachePointerEvents ??= /* @__PURE__ */ new Map();\n  }\n  function endAriaCaches() {\n    if (!--cachesCounter) {\n      cacheAccessibleName = void 0;\n      cacheAccessibleNameHidden = void 0;\n      cacheIsHidden = void 0;\n      cachePseudoContent = void 0;\n      cachePseudoContentBefore = void 0;\n      cachePseudoContentAfter = void 0;\n      cachePointerEvents = void 0;\n    }\n  }\n  var inputTypeToRole = {\n    button: "button",\n    checkbox: "checkbox",\n    image: "button",\n    number: "spinbutton",\n    radio: "radio",\n    range: "slider",\n    reset: "button",\n    submit: "button"\n  };\n\n  // src/browser/ariaTree/yamlUtils.ts\n  function yamlEscapeKeyIfNeeded(str) {\n    if (!yamlStringNeedsQuotes(str)) return str;\n    return `\'` + str.replace(/\'/g, `\'\'`) + `\'`;\n  }\n  function yamlEscapeValueIfNeeded(str) {\n    if (!yamlStringNeedsQuotes(str)) return str;\n    return \'"\' + str.replace(/[\\\\"\\x00-\\x1f\\x7f-\\x9f]/g, (c) => {\n      switch (c) {\n        case "\\\\":\n          return "\\\\\\\\";\n        case \'"\':\n          return \'\\\\"\';\n        case "\\b":\n          return "\\\\b";\n        case "\\f":\n          return "\\\\f";\n        case "\\n":\n          return "\\\\n";\n        case "\\r":\n          return "\\\\r";\n        case "\t":\n          return "\\\\t";\n        default:\n          const code = c.charCodeAt(0);\n          return "\\\\x" + code.toString(16).padStart(2, "0");\n      }\n    }) + \'"\';\n  }\n  function yamlStringNeedsQuotes(str) {\n    if (str.length === 0) return true;\n    if (/^\\s|\\s$/.test(str)) return true;\n    if (/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f-\\x9f]/.test(str)) return true;\n    if (/^-/.test(str)) return true;\n    if (/[\\n:](\\s|$)/.test(str)) return true;\n    if (/\\s#/.test(str)) return true;\n    if (/[\\n\\r]/.test(str)) return true;\n    if (/^[&*\\],?!>|@"\'#%]/.test(str)) return true;\n    if (/[{}`]/.test(str)) return true;\n    if (/^\\[/.test(str)) return true;\n    if (!isNaN(Number(str)) || ["y", "n", "yes", "no", "true", "false", "on", "off", "null"].includes(str.toLowerCase()))\n      return true;\n    return false;\n  }\n\n  // src/browser/ariaTree/ariaSnapshot.ts\n  function generateAndRenderAriaTree(root, counter) {\n    const refCounter = counter || { value: 0 };\n    root.querySelectorAll("[data-spark-ref]").forEach((el) => {\n      el.removeAttribute("data-spark-ref");\n      el.removeAttribute("data-spark-role");\n    });\n    const ariaTree = generateAriaTree(root);\n    return renderAriaTree(ariaTree, refCounter);\n  }\n  var MAX_IFRAME_DEPTH = 5;\n  function generateAriaTree(rootElement, iframeDepth = 0) {\n    const visited = /* @__PURE__ */ new Set();\n    const root = {\n      role: "fragment",\n      name: "",\n      children: [],\n      element: rootElement,\n      props: {},\n      box: box(rootElement),\n      receivesPointerEvents: true\n    };\n    const visit = (ariaNode, node) => {\n      if (visited.has(node)) return;\n      visited.add(node);\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\n        const text = node.nodeValue;\n        if (ariaNode.role !== "textbox" && text) ariaNode.children.push(node.nodeValue || "");\n        return;\n      }\n      if (node.nodeType !== Node.ELEMENT_NODE) return;\n      const element = node;\n      let isVisible = !isElementHiddenForAria(element);\n      isVisible = isVisible || isElementVisible(element);\n      if (!isVisible) return;\n      const ariaChildren = [];\n      if (element.hasAttribute("aria-owns")) {\n        const ids = element.getAttribute("aria-owns").split(/\\s+/);\n        for (const id of ids) {\n          const ownedElement = rootElement.ownerDocument.getElementById(id);\n          if (ownedElement) ariaChildren.push(ownedElement);\n        }\n      }\n      if (element.nodeName === "IFRAME") {\n        if (iframeDepth >= MAX_IFRAME_DEPTH) return;\n        const iframe = element;\n        try {\n          const iframeDoc = iframe.contentDocument;\n          if (iframeDoc && iframeDoc.body) {\n            iframeDoc.body.querySelectorAll("[data-spark-ref]").forEach((el) => el.removeAttribute("data-spark-ref"));\n            const iframeTree = generateAriaTree(iframeDoc.body, iframeDepth + 1);\n            for (const child of iframeTree.children) {\n              ariaNode.children.push(child);\n            }\n            return;\n          }\n        } catch {\n        }\n        const iframeNode = {\n          role: "iframe",\n          name: "",\n          children: [],\n          props: {},\n          element,\n          box: box(element),\n          receivesPointerEvents: true\n        };\n        ariaNode.children.push(iframeNode);\n        return;\n      }\n      const childAriaNode = toAriaNode(element);\n      if (childAriaNode) {\n        ariaNode.children.push(childAriaNode);\n      }\n      processElement(childAriaNode || ariaNode, element, ariaChildren);\n    };\n    function processElement(ariaNode, element, ariaChildren = []) {\n      const display = getElementComputedStyle(element)?.display || "inline";\n      const treatAsBlock = display !== "inline" || element.nodeName === "BR" ? " " : "";\n      if (treatAsBlock) ariaNode.children.push(treatAsBlock);\n      ariaNode.children.push(getCSSContent(element, "::before") || "");\n      const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n      if (assignedNodes.length) {\n        for (const child of assignedNodes) visit(ariaNode, child);\n      } else {\n        for (let child = element.firstChild; child; child = child.nextSibling) {\n          if (!child.assignedSlot) visit(ariaNode, child);\n        }\n        if (element.shadowRoot) {\n          for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n            visit(ariaNode, child);\n        }\n      }\n      for (const child of ariaChildren) visit(ariaNode, child);\n      ariaNode.children.push(getCSSContent(element, "::after") || "");\n      if (treatAsBlock) ariaNode.children.push(treatAsBlock);\n      if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0])\n        ariaNode.children = [];\n      if (ariaNode.role === "link" && element.hasAttribute("href")) {\n        const href = element.getAttribute("href");\n        ariaNode.props["url"] = href;\n      }\n    }\n    beginAriaCaches();\n    try {\n      visit(root, rootElement);\n    } finally {\n      endAriaCaches();\n    }\n    normalizeStringChildren(root);\n    normalizeGenericRoles(root);\n    return root;\n  }\n  function toAriaNode(element) {\n    const role = getAriaRole(element) ?? "generic";\n    if (role === "presentation" || role === "none") return null;\n    const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || "");\n    const pointerEvents = receivesPointerEvents(element);\n    const result = {\n      role,\n      name,\n      children: [],\n      props: {},\n      element,\n      box: box(element),\n      receivesPointerEvents: pointerEvents\n    };\n    if (kAriaCheckedRoles.includes(role))\n      result.checked = getAriaChecked(element);\n    if (kAriaDisabledRoles.includes(role))\n      result.disabled = getAriaDisabled(element);\n    if (kAriaExpandedRoles.includes(role))\n      result.expanded = getAriaExpanded(element);\n    if (kAriaLevelRoles.includes(role)) result.level = getAriaLevel(element);\n    if (kAriaPressedRoles.includes(role))\n      result.pressed = getAriaPressed(element);\n    if (kAriaSelectedRoles.includes(role))\n      result.selected = getAriaSelected(element);\n    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n      const nonTextTypes = ["password", "checkbox", "radio", "file"];\n      const sensitiveAutocomplete = [\n        "cc-number",\n        "cc-name",\n        "cc-csc",\n        "cc-exp",\n        "cc-exp-month",\n        "cc-exp-year",\n        "cc-type",\n        "new-password",\n        "current-password",\n        "one-time-code"\n      ];\n      const autocomplete = element.getAttribute("autocomplete") || "";\n      if (!nonTextTypes.includes(element.type) && !sensitiveAutocomplete.includes(autocomplete)) {\n        result.children = [element.value];\n      }\n    }\n    return result;\n  }\n  function normalizeGenericRoles(node) {\n    const normalizeChildren = (node2) => {\n      const result = [];\n      for (const child of node2.children || []) {\n        if (typeof child === "string") {\n          result.push(child);\n          continue;\n        }\n        const normalized = normalizeChildren(child);\n        result.push(...normalized);\n      }\n      const removeSelf = node2.role === "generic" && result.length <= 1 && result.every((c) => typeof c !== "string" && nodeReceivesPointerEvents(c));\n      if (removeSelf) return result;\n      node2.children = result;\n      return [node2];\n    };\n    normalizeChildren(node);\n  }\n  function normalizeStringChildren(rootA11yNode) {\n    const flushChildren = (buffer, normalizedChildren) => {\n      if (!buffer.length) return;\n      const text = normalizeWhiteSpace(buffer.join(""));\n      if (text) normalizedChildren.push(text);\n      buffer.length = 0;\n    };\n    const visit = (ariaNode) => {\n      const normalizedChildren = [];\n      const buffer = [];\n      for (const child of ariaNode.children || []) {\n        if (typeof child === "string") {\n          buffer.push(child);\n        } else {\n          flushChildren(buffer, normalizedChildren);\n          visit(child);\n          normalizedChildren.push(child);\n        }\n      }\n      flushChildren(buffer, normalizedChildren);\n      ariaNode.children = normalizedChildren.length ? normalizedChildren : [];\n      if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name)\n        ariaNode.children = [];\n    };\n    visit(rootA11yNode);\n  }\n  var SOM_CONTAINER_ID = "__spark-som-container";\n  var SOM_COLORS = [\n    "#e6194b",\n    // red\n    "#3cb44b",\n    // green\n    "#4363d8",\n    // blue\n    "#f58231",\n    // orange\n    "#911eb4",\n    // purple\n    "#42d4f4"\n    // cyan\n  ];\n  var SOM_INTERACTIVE_TAGS = /* @__PURE__ */ new Set(["A", "BUTTON", "INPUT", "SELECT", "TEXTAREA", "SUMMARY"]);\n  var SOM_INTERACTIVE_ROLES = /* @__PURE__ */ new Set([\n    "button",\n    "link",\n    "textbox",\n    "combobox",\n    "checkbox",\n    "radio",\n    "switch",\n    "slider",\n    "spinbutton",\n    "searchbox",\n    "option",\n    "menuitem",\n    "menuitemcheckbox",\n    "menuitemradio",\n    "tab",\n    "treeitem",\n    "gridcell",\n    "columnheader",\n    "rowheader"\n  ]);\n  function isInteractiveElement(el) {\n    if (SOM_INTERACTIVE_TAGS.has(el.tagName)) return true;\n    const ce = el.getAttribute("contenteditable");\n    if (ce === "true" || ce === "") return true;\n    const computedRole = el.getAttribute("data-spark-role");\n    if (computedRole && SOM_INTERACTIVE_ROLES.has(computedRole)) return true;\n    const rawRole = el.getAttribute("role");\n    if (rawRole) {\n      const roles = rawRole.split(/\\s+/);\n      if (roles.some((r) => SOM_INTERACTIVE_ROLES.has(r))) return true;\n    }\n    const tabindex = el.getAttribute("tabindex");\n    if (tabindex !== null) {\n      const tabValue = parseInt(tabindex, 10);\n      if (!isNaN(tabValue) && tabValue >= 0 && (!computedRole || computedRole === "generic")) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function applySetOfMarks() {\n    removeSetOfMarks();\n    if (!document.body) return;\n    const container = document.createElement("div");\n    container.id = SOM_CONTAINER_ID;\n    container.style.cssText = "position:fixed;top:0;left:0;width:0;height:0;pointer-events:none;z-index:2147483647;";\n    const elements = document.querySelectorAll("[data-spark-ref]");\n    let colorIndex = 0;\n    elements.forEach((el) => {\n      const ref = el.getAttribute("data-spark-ref");\n      if (!ref) return;\n      if (!isInteractiveElement(el)) return;\n      const rect = el.getBoundingClientRect();\n      if (rect.width === 0 && rect.height === 0) return;\n      const color = SOM_COLORS[colorIndex % SOM_COLORS.length];\n      const absTop = rect.top + window.scrollY;\n      const absLeft = rect.left + window.scrollX;\n      const outline = document.createElement("div");\n      outline.style.cssText = `position:absolute;top:${absTop}px;left:${absLeft}px;width:${rect.width}px;height:${rect.height}px;border:2px solid ${color};box-sizing:border-box;border-radius:2px;`;\n      container.appendChild(outline);\n      const badge = document.createElement("div");\n      badge.textContent = ref;\n      badge.style.cssText = `position:absolute;top:${absTop}px;left:${absLeft}px;background:${color};color:#fff;font:bold 11px monospace;padding:1px 3px;border-radius:2px;line-height:1.2;white-space:nowrap;`;\n      container.appendChild(badge);\n      colorIndex++;\n    });\n    document.body.appendChild(container);\n  }\n  function removeSetOfMarks() {\n    const existing = document.getElementById(SOM_CONTAINER_ID);\n    if (existing) existing.remove();\n  }\n  function nodeReceivesPointerEvents(ariaNode) {\n    return ariaNode.box.visible && ariaNode.receivesPointerEvents;\n  }\n  function hasPointerCursor(ariaNode) {\n    return ariaNode.box.style?.cursor === "pointer";\n  }\n  function renderAriaTree(root, counter) {\n    const lines = [];\n    const visit = (ariaNode, _parentAriaNode, indent) => {\n      if (typeof ariaNode === "string") {\n        const text = yamlEscapeValueIfNeeded(ariaNode);\n        if (text) lines.push(indent + "- text: " + text);\n        return;\n      }\n      let key = ariaNode.role;\n      if (ariaNode.name) {\n        const displayName = ariaNode.name.length > 900 ? ariaNode.name.slice(0, 900) + "..." : ariaNode.name;\n        const stringifiedName = JSON.stringify(displayName);\n        key += " " + stringifiedName;\n      }\n      if (ariaNode.checked === "mixed") key += ` [checked=mixed]`;\n      if (ariaNode.checked === true) key += ` [checked]`;\n      if (ariaNode.disabled) key += ` [disabled]`;\n      if (ariaNode.expanded) key += ` [expanded]`;\n      if (ariaNode.level) key += ` [level=${ariaNode.level}]`;\n      if (ariaNode.pressed === "mixed") key += ` [pressed=mixed]`;\n      if (ariaNode.pressed === true) key += ` [pressed]`;\n      if (ariaNode.selected === true) key += ` [selected]`;\n      if (nodeReceivesPointerEvents(ariaNode)) {\n        const ref = "E" + ++counter.value;\n        const cursor = hasPointerCursor(ariaNode) ? " [cursor=pointer]" : "";\n        key += ` [ref=${ref}]${cursor}`;\n        ariaNode.element?.setAttribute("data-spark-ref", ref);\n        ariaNode.element?.setAttribute("data-spark-role", ariaNode.role);\n      }\n      const escapedKey = indent + "- " + yamlEscapeKeyIfNeeded(key);\n      const hasProps = !!Object.keys(ariaNode.props).length;\n      if (!ariaNode.children.length && !hasProps) {\n        lines.push(escapedKey);\n      } else if (ariaNode.children.length === 1 && typeof ariaNode.children[0] === "string" && !hasProps) {\n        const text = ariaNode.children[0];\n        if (text) lines.push(escapedKey + ": " + yamlEscapeValueIfNeeded(text));\n        else lines.push(escapedKey);\n      } else {\n        lines.push(escapedKey + ":");\n        for (const [name, value] of Object.entries(ariaNode.props))\n          lines.push(indent + "  - /" + name + ": " + yamlEscapeValueIfNeeded(value));\n        for (const child of ariaNode.children || []) visit(child, ariaNode, indent + "  ");\n      }\n    };\n    if (root.role === "fragment") {\n      for (const child of root.children || []) visit(child, root, "");\n    } else {\n      visit(root, null, "");\n    }\n    return lines.join("\\n");\n  }\n  return __toCommonJS(ariaSnapshot_exports);\n})();\n\nglobalThis.__sparkAriaTree = __sparkAriaTree;\n';
